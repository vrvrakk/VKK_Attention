import slab
import numpy
import os
from pathlib import Path
sample_freq = 24414
file_path = 'C:/Users/vrvra/PycharmProjects/VKK_Attention/data/voices/voice4/s_29.wav'
max_duration = 745/1000
s = slab.Sound(data=file_path, duration=max_duration, samplerate=sample_freq)

silence = slab.Sound.silence(duration=0.01) # 10 ms silence
signal = slab.Sound.tone(duration=0.05) # using the default 500 Hz
signal.level = 80 # let's start at the same intensity as the masker
signal.ramp(duration=0.005) # short signal, we'll use 5 ms ramps
stimulus = slab.Sound.sequence(masker, silence, signal)
stimulus.play()

# get list with dur of each trial:
n_samples_ms_dict = dict(zip(numbers, n_samples_ms))
overlapping_trials = [True]
while overlapping_trials:
    trials_dur1 = []
    for index1, trial1 in enumerate(trial_seq1.trials):
        duration1 = n_samples_ms_dict.get(trial1)
        print(duration1)
        t1_onset = index1 * tlo1  # trial1 onsets
        t1_offset = t1_onset + tlo1
        if duration1 is not None:
            trials_dur1.append((index1, trial1, t1_onset, duration1, t1_offset))

    # now for trial_seq2.trials:
    trials_dur2 = []
    for index2, trial2 in enumerate(trial_seq2.trials):
        duration2 = n_samples_ms_dict.get(trial2)
        t2_onset = index2 * tlo2
        t2_offset = t2_onset + tlo2
        if duration2 is not None:
            trials_dur2.append((index2, trial2, t2_onset, duration2, t2_offset))

    # make sure both streams have different numbers at concurrent trials:
    # Step 1: Handle direct overlaps with the same number
    overlapping_trials = []
    for index2, trial2, t2_onset, duration2, t2_offset in trials_dur2:
        for index1, trial1, t1_onset, duration1, t1_offset in trials_dur1:
            if t1_onset < t2_offset and t2_onset < t1_offset and trial1 == trial2:
                overlapping_trials.append((index1, trial1, index2, trial2))
    print(overlapping_trials)
    print(len(overlapping_trials))

    for index1, trial1, index2, trial2 in overlapping_trials:  # TODO: check if it truly worked...
        prev_trial1 = trials_dur1[index1 - 1][1] if index1 > 0 else None  # index [1] entails the trial number
        next_trial1 = trials_dur1[index1 + 1][1] if index1 < len(trials_dur1) - 1 else None
        prev_trial2 = trials_dur2[index2 - 1][1] if index2 > 0 else None
        next_trial2 = trials_dur2[index2 + 1][1] if index2 < len(trials_dur2) - 1 else None
        # Find a replacement number for trial2
        exclude_numbers = {trial1, prev_trial1, next_trial1, prev_trial2, next_trial2}
        possible_numbers = [n for n in numbers if n not in exclude_numbers]
        if possible_numbers:
            new_number = random.choice(possible_numbers)
            trial_seq2.trials[index2] = new_number

    index2: int  # additional condition:
    for index2, trial2 in enumerate(trial_seq2.trials):
        current_trial = trial2
        prev_trial = trial_seq2.trials[index2 - 1] if index2 > 0 else None
        next_trial = trial_seq2.trials[index2 + 1] if index2 < len(trial_seq2.trials) - 1 else None
        # Initialize exclude_numbers based on the existence of prev_trial and next_trial
        if prev_trial is not None and next_trial is not None:  # none statements implemented for accuracy
            exclude_numbers = {current_trial, prev_trial, next_trial}
        elif prev_trial is not None:
            exclude_numbers = {current_trial, prev_trial}
        elif next_trial is not None:
            exclude_numbers = {current_trial, next_trial}
        else:
            exclude_numbers = {current_trial}
        # Check for consecutive same numbers and replace if necessary
        if current_trial == prev_trial or (next_trial is not None and current_trial == next_trial):
            possible_numbers = [n for n in numbers if n not in exclude_numbers]
            if possible_numbers:
                new_number = random.choice(possible_numbers)
                trial_seq2.trials[index2] = new_number
##########
# other version:
captured_trials = []
    # Identify all trials within each time window
    for index1, trial1, t1_onset, duration1, t1_offset in trials_dur1:
        window_start = max(0, t1_onset - isi[0])  # Ensure window_start is not negative
        window_end = t1_offset + isi[0]
        for index2, trial2, t2_onset, duration2, t2_offset in trials_dur2:
            if t2_onset > window_start and t2_offset < window_end:
                captured_trials.append((index1, trial1, index2, trial2))

    for i, (index1, trial1, index2, trial2) in enumerate(captured_trials):
        print(i, (index1, trial1, index2, trial2))
        prev_trial1 = trials_dur1[index1 - 1][1] if index1 > 0 else None
        prev_trial2 = trials_dur2[index2 - 1][1] if index2 > 0 else None
        next_trial1 = trials_dur1[index1 + 1][1] if index1 < len(trials_dur1) - 1 else None
        next_trial2 = trials_dur2[index2 + 1][1] if index2 < len(trials_dur2) - 1 else None
        prev_index1 = trials_dur1[index1 - 1][0] if index1 > 0 else None
        prev_index2 = trials_dur2[index2 - 1][0] if index2 > 0 else None
        next_index1 = trials_dur1[index1 + 1][0] if index1 < len(trials_dur1) - 1 else None

        exclude_numbers = {trial1, prev_trial1, prev_trial2, next_trial1, next_trial2}
        exclude_numbers.discard(None)
        if i > 0:
            if prev_index1 == index1:
                exclude_numbers.remove(prev_trial1)  # only remove prev_trial1 if prev_index1== index1
            elif prev_index2 == index2:
                exclude_numbers.remove(prev_trial2)
        if i < len(trials_dur2) - 1:
            if next_index1 == index1:
                exclude_numbers.remove(next_trial1)
        if trial1 == trial2 or trial2 == prev_trial1 or trial2 == next_trial1:
            possible_numbers = [n for n in numbers if n not in exclude_numbers]
            if possible_numbers:
                new_number = random.choice(possible_numbers)
                trial_seq2.trials[index2] = new_number
## template:


def validate_replacement(index, s2, replacement):
    # Check adjacent numbers for conflicts
    if index > 0 and s2[index - 1] == replacement:
        return False
    if index < len(s2) - 1 and s2[index + 1] == replacement:
        return False
    return True

for index, replacement in replacements.items():
    s2[index] = replacement  # Update s2 with the new number
